-- library declaration
library IEEE;
use IEEE.std_logic_1164.all;


-- entity
entity ckt_rtl is
   port 
    (
      D1_IN,D2_IN : in std_logic_vector(7 downto 0);
      CLK,SEL : in std_logic;
      LDA,LDB : in std_logic;
      REG_A,REG_B : out std_logic_vector(7 downto 0)
    );
end ckt_rtl;
--Notice the only signals not declared here the inputs of the two registers (the output of the multiplexer)

-- architecture
architecture rtl_behavioral of ckt_rtl is
 
  -- intermediate signal declaration ---------------
  signal s_mux_result : std_logic_vector(7 downto 0); 
      begin
         ra: process(CLK) -- process
          begin
              if (rising_edge(CLK)) then if (LDA = '1') then
                REG_A <= s_mux_result;
              end if;
          end if;
        end process;
        
         rb: process(CLK) -- process
          begin
              if (rising_edge(CLK)) then if (LDB = '1') then
                REG_B <= s_mux_result;
              end if;
          end if;
        end process;
        
        
        with SEL select
        s_mux_result  <= D1_IN when '1',
                      D2_IN when '0',
                      (others => '0') when others;
end rtl_behavioral;

--Notice that we declared a detailed signal for the registers inputs. Also, notice that for the multiplexer we have to do
--a more detailed code compared to the one we did in the Synthesis_lab. In this case we specified the 1's and 0's
--Also, notice that although its only 2 inputs for the multiplexer, we use bundles (8) for each one.
--Also notice here that we don't make SEL a vector because, we only use one column of 1's and 0's. If we used two
--columms, we would use a SEL vector of 2.
